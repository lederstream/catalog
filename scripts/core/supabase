// scripts/core/supabase.js
import { Utils } from './utils.js';

class SupabaseClient {
    constructor() {
        this.supabaseUrl = 'https://fwmpcglrwgfougbgxvnt.supabase.co';
        this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ3bXBjZ2xyd2dmb3VnYmd4dm50Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1NzI2MzQsImV4cCI6MjA3MTE0ODYzNH0.gbW0YSUmBxGyI0XmSckKvOszNME3b4RIt5HLZa4Amjc';
        this.init();
    }

    init() {
        try {
            // Intenta cargar Supabase desde CDN si no está disponible
            if (typeof supabase === 'undefined') {
                this.loadSupabaseFromCDN();
            } else {
                this.client = supabase.createClient(this.supabaseUrl, this.supabaseKey);
                console.log('✅ Supabase conectado correctamente');
            }
        } catch (error) {
            console.error('❌ Error inicializando Supabase:', error);
            this.setupMockData();
        }
    }

    loadSupabaseFromCDN() {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
        script.onload = () => {
            this.client = supabase.createClient(this.supabaseUrl, this.supabaseKey);
            console.log('✅ Supabase cargado desde CDN y conectado correctamente');
        };
        script.onerror = () => {
            console.warn('⚠️ No se pudo cargar Supabase desde CDN, usando datos mock');
            this.setupMockData();
        };
        document.head.appendChild(script);
    }

    setupMockData() {
        console.warn('⚠️ Usando datos de prueba (mock)');
        this.mockData = {
            products: [],
            categories: []
        };
        // Datos de ejemplo para desarrollo
        this.mockData.categories = [
            { id: 1, name: 'Hosting', description: 'Servicios de alojamiento web' },
            { id: 2, name: 'Dominios', description: 'Registro de nombres de dominio' },
            { id: 3, name: 'SSL', description: 'Certificados de seguridad' }
        ];
        
        this.mockData.products = [
            {
                id: 1,
                name: 'Hosting Básico',
                description: 'Plan ideal para sitios web pequeños',
                category_id: 1,
                photo_url: 'https://via.placeholder.com/300x200?text=Hosting+Básico',
                plans: [{ name: 'Básico', price_soles: 29.90, price_dollars: 9.90 }],
                created_at: new Date().toISOString()
            }
        ];
    }

    // Métodos para categorías
    async getCategories() {
        if (this.client) {
            const { data, error } = await this.client
                .from('categories')
                .select('*')
                .order('name');
            
            if (error) throw error;
            return data;
        }
        return this.mockData.categories;
    }

    async addCategory(categoryData) {
        if (this.client) {
            const { data, error } = await this.client
                .from('categories')
                .insert([categoryData])
                .select()
                .single();
            
            if (error) throw error;
            return data;
        }
        
        // Mock implementation
        const newCategory = {
            id: Math.max(...this.mockData.categories.map(c => c.id)) + 1,
            ...categoryData,
            created_at: new Date().toISOString()
        };
        this.mockData.categories.push(newCategory);
        return newCategory;
    }

    async updateCategory(id, categoryData) {
        if (this.client) {
            const { data, error } = await this.client
                .from('categories')
                .update(categoryData)
                .eq('id', id)
                .select()
                .single();
            
            if (error) throw error;
            return data;
        }
        
        // Mock implementation
        const index = this.mockData.categories.findIndex(c => c.id === id);
        if (index !== -1) {
            this.mockData.categories[index] = { ...this.mockData.categories[index], ...categoryData };
            return this.mockData.categories[index];
        }
        return null;
    }

    async deleteCategory(id) {
        if (this.client) {
            const { error } = await this.client
                .from('categories')
                .delete()
                .eq('id', id);
            
            if (error) throw error;
            return true;
        }
        
        // Mock implementation
        this.mockData.categories = this.mockData.categories.filter(c => c.id !== id);
        return true;
    }

    // Métodos para productos
    async getProducts() {
        if (this.client) {
            const { data, error } = await this.client
                .from('products')
                .select(`
                    *,
                    categories (name)
                `)
                .order('created_at', { ascending: false });
            
            if (error) throw error;
            return data;
        }
        return this.mockData.products;
    }

    async addProduct(productData) {
        if (this.client) {
            const { data, error } = await this.client
                .from('products')
                .insert([productData])
                .select(`
                    *,
                    categories (name)
                `)
                .single();
            
            if (error) throw error;
            return data;
        }
        
        // Mock implementation
        const newProduct = {
            id: Math.max(...this.mockData.products.map(p => p.id), 0) + 1,
            ...productData,
            created_at: new Date().toISOString()
        };
        this.mockData.products.unshift(newProduct);
        return newProduct;
    }

    async updateProduct(id, productData) {
        if (this.client) {
            const { data, error } = await this.client
                .from('products')
                .update(productData)
                .eq('id', id)
                .select(`
                    *,
                    categories (name)
                `)
                .single();
            
            if (error) throw error;
            return data;
        }
        
        // Mock implementation
        const index = this.mockData.products.findIndex(p => p.id === id);
        if (index !== -1) {
            this.mockData.products[index] = { ...this.mockData.products[index], ...productData };
            return this.mockData.products[index];
        }
        return null;
    }

    async deleteProduct(id) {
        if (this.client) {
            const { error } = await this.client
                .from('products')
                .delete()
                .eq('id', id);
            
            if (error) throw error;
            return true;
        }
        
        // Mock implementation
        this.mockData.products = this.mockData.products.filter(p => p.id !== id);
        return true;
    }
}

// Crear instancia única
let supabaseClientInstance = null;

export function getSupabaseClient() {
    if (!supabaseClientInstance) {
        supabaseClientInstance = new SupabaseClient();
    }
    return supabaseClientInstance;
}

// Para compatibilidad con código existente
export const supabaseClient = {
    getCategories: () => getSupabaseClient().getCategories(),
    addCategory: (categoryData) => getSupabaseClient().addCategory(categoryData),
    updateCategory: (id, categoryData) => getSupabaseClient().updateCategory(id, categoryData),
    deleteCategory: (id) => getSupabaseClient().deleteCategory(id),
    getProducts: () => getSupabaseClient().getProducts(),
    addProduct: (productData) => getSupabaseClient().addProduct(productData),
    updateProduct: (id, productData) => getSupabaseClient().updateProduct(id, productData),
    deleteProduct: (id) => getSupabaseClient().deleteProduct(id)
};
